# SSHScript v2.0 Connect

Last Updated on 2023/10/20

<div style="text-align:right;position:relative;top:-140px"><a href="./index">Back to Index</a></div>

## Topics

* [Connect by Password](#bypassword)
* [Connect by SSH Key](#bykey)
* [Connect by ProxyCommand](#byproxycommand)
* [Nested Connection](#nested)

## ðŸ”µ <a name="bypassword"></a>Connect by Password

The common approach to connect is to connect by account and password. For example:
```
## filename: example.spy
## run: sshscript example.spy
with $.connect('user@host','1234') as host_session:
    $hostname
    assert $.stdout.strip() == 'host'
```
Or with sshscript module:
```
## filename: example.py
## run: python3 example.py
import sshscript
session = sshscript.SSHScriptSession()
with session.connect('user@host','1234') as host_session:
    host_session('hostname')
    assert host_session.stdout.strip() == 'host'
```


## ðŸ”µ <a name="bykey"></a>Connect by SSH Key

The recommanded approach to connect is to connect by account and SSH key. 
The key is generated by `ssh-keygen`. 
```
## filename: example.spy
## run: sshscript example.spy
## You can tell Paramiko which key to use
with $.connect('user@host',pkey=$.pkey('/path/to/key')) as host_session:
    $hostname
    assert $.stdout.strip() == 'host'

## Without password and pkey, Paramiko would serch your localhost for default sshkey
## Which usually is ".ssh/id_rsa" under your home directory
with $.connect('user@host') as host_session:
    pass
```

## ðŸ”µ <a name="bykey"></a>Connect by ProxyCommand
The keyword arguments passed to `connect()`, except for "policy", are pass-through to paramiko.SSHClient().connect().
So if you want to connect by ProxyCommand, you can use the following example:
```
with $.connect('user@host',proxyCommand='openssl s_client -ign_eof -connect 1.2.3.4:5555 -quiet') :
    $hostname
    assert $.stdout.strip() == 'host'
```

### 
## ðŸ”µ <a name="nested"></a>Nested Connections
Connecting from a bridge host to a protected host is easy.
```
with $.connect('user@bridge','1234') as host_session:
    with $.connect('user@database','1234') as inner_host_session:
        inner_host_session('hostname')
        assert inner_host_session.stdout.strip() == 'database'
```
Just layer them, you can make your connection deeper and deeper.

Please note that when making a nested connection with hostname must be
resolable by the host on the middle. In the following example, 
the hostname "bridge" is resolved by localhost.
The hostname "database" should be resolable by the "bridge" host.
The hostname "accounts" should be resolable by the "database" host.
```
with $.connect('user@bridge','1234') as host_session:
    with $.connect('user@database','1234') as inner_host_session:
        with $.connect('user@accounts','1234') as inner_inner_host_session:
            inner_inner_host_session('hostname')
            assert inner_inner_host_session.stdout.strip() == 'accounts'
```


The paramiko always searches ssh key on localhost.
On the following example, when connecting to the "database" host, 
the paramiko would using the ssh key on localhost.
```
## using the ssh key on localhost
with $.connect('user@bridge') as host_session:
    ## still using the ssh key on localhost
    with $.connect('user@database') as inner_host_session:
        inner_host_session('hostname')
        assert inner_host_session.stdout.strip() == 'database'
```
If you want to use the pkey on the "bridge" host, you should assign the pkey again by using the $.pkey() function.
Like the following example shows
```
## using the ssh key on localhost
with $.connect('user@bridge') as host_session:
    ## "/home/user/.ssh/id_rsa" is on the "bridge" host
    pkey = $.pkey('/home/user/.ssh/id_rsa')
    with $.connect('user@database',pkey=pkey) as inner_host_session:
        inner_host_session('hostname')
        assert inner_host_session.stdout.strip() == 'database'
```

